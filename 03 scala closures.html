<center><a href="http://www.scala-lang.org"><img src="http://www.urubatan.com.br/wp-content/uploads/2011/01/newsflash_logo-e1295973840911.png" alt="" title="Scala" /></a></center>
Depois de uma breve <a href="http://www.urubatan.com.br/introducao-a-linguagem-scala/">introdução a linguagem Scala</a>, e de falar sobre <a href="http://www.urubatan.com.br/orientacao-a-objetos-em-scala/">orientação a objetos em Scala</a>, agora vamos falar um pouquinho de closures em Scala, mas não apenas de closures, de blocos de código, closures automáticas, e vamos começar a falar de alguns dos recursos funcionais da linguagem, como Higher-Order functions, funções como valor e passar funções como parâmetros para outras funções.
Veja bem, este post não vai ser uma introdução a programação funcional em scala, pretendo fazer isto mais adiante, mas aproveitando o gancho das closures, como alguns dos conceitos do que vou falar são bem parecidos, já vamos também estudar alguns dos conceitos básicos que permitem programação funcional com a linguagem scala.

Então sem mais delongas, vamos a alguns conceitos:
<strong>Closure</strong> é uma função de primeira classe com variáveis livres, ligadas ao contexto onde a closure foi criada.
Lendo esta definição, já que closure é uma função de primeira classe, quer dizer que Scala possui funções de primeira classe.
<strong>Funções de primeira classe</strong> são funções tratadas como objetos, que podem ser armazenados em estruturas de dados, ser passados como parâmetros para outras funções e podem ser o valor de retorno para outras funções.
Lendo esta definição de funções de primeira classe, ou first-class functions, uma parte desta definição me lembra da definição de Higher-Order functions, veja abaixo:
<strong>Higher-Order Functions</strong> são funções que recebem uma ou mais funções como parâmetros e/ou retornam uma função.
Juntando tudo isto, e partindo do principio que Scala suporta Closures podemos também inferir que scala suporta higher-order functions, uma caracteristica bastante comum de linguagens de programação funcionais.

<h2>Voltando as Closures</h2>
Vamos começar com um exemplo, para facilitar as expicações:

{{samples/013_closure.scala}}

Na linha 2, o método printResult precisa receber como parâmetro uma função que receba um Int como parâmetro e retorne qualquer coisa.
Na linha 3 chamamos esta função passando 5 como parâmetro e passamos o resultado dela para o println.
Se você lêr novamente a definição de higher-order function, esta função definida na linha 2 é um exemplo bem simples de uma, até agora temos uma higher-order function, mas nenhuma closure.

Na linha 7, definimos uma variável "funcParam" que aponta para uma função anonima, que recebe um Int e retorna um Int.
Esta é uma função de primeira classe, estamos armazenando uma função em uma variável, que poderia ser parte de uma estrutura de dados, e na linha 8, estamos passando esta função armazenada em uma variável como parâmetro para outra função.
Mas o que define esta função anonima declarada na linha 7 como uma closure, alem de ser uma função de primeira classe, é que ela acessa uma variável local do método onde ela foi definida, dentro da closure, é armazenada uma referência para a variável definida no mesmo contexto onde esta closure foi criada, e quando a closure é executada ela lê o valor atual da variável, e não o valor que esta variável tinha quando a closure foi criada. Ou seja, mesmo sendo executada em um lugar totalmente diferente, a closure é executada no contexto onde ela foi declarada.

Isto pode parecer um pouco complexo, mas com o tempo vai ficando bem simples.

<h2>Criação atomática de Closures</h2>

{{samples/014_whileloop.scala}}

{{samples/015_loop.scala}}

